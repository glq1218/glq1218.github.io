import{_ as n,o as e,c as l,a as r}from"./app.7d3e96bc.js";const a="/assets/Eureka原理图.473fe5da.png",t="/assets/10122164F-0.96dd8b3c.png",i="/assets/1012212Q4-1.2b120d46.png",p="/assets/101623H11-0.5269135a.png",y=JSON.parse('{"title":"SpringCloud笔记","description":"","frontmatter":{},"headers":[{"level":2,"title":"SpringCloud","slug":"springcloud","link":"#springcloud","children":[{"level":3,"title":"SpringCloud 是什么","slug":"springcloud-是什么","link":"#springcloud-是什么","children":[]},{"level":3,"title":"Spring Cloud 常用组件","slug":"spring-cloud-常用组件","link":"#spring-cloud-常用组件","children":[]},{"level":3,"title":"Spring Boot 和 Spring Cloud 的区别与联系","slug":"spring-boot-和-spring-cloud-的区别与联系","link":"#spring-boot-和-spring-cloud-的区别与联系","children":[]},{"level":3,"title":"Spring Cloud 版本","slug":"spring-cloud-版本","link":"#spring-cloud-版本","children":[]},{"level":3,"title":"Spring Cloud 版本选择","slug":"spring-cloud-版本选择","link":"#spring-cloud-版本选择","children":[]}]},{"level":2,"title":"Eureka：Spring Cloud服务注册与发现组件","slug":"eureka-spring-cloud服务注册与发现组件","link":"#eureka-spring-cloud服务注册与发现组件","children":[{"level":3,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":3,"title":"Eureka两大组件","slug":"eureka两大组件","link":"#eureka两大组件","children":[]},{"level":3,"title":"Eureka 服务注册与发现","slug":"eureka-服务注册与发现","link":"#eureka-服务注册与发现","children":[]},{"level":3,"title":"Eureka SpringCloud 官方地址","slug":"eureka-springcloud-官方地址","link":"#eureka-springcloud-官方地址","children":[]}]},{"level":2,"title":"Ribbon：Spring Cloud负载均衡与服务调用组件","slug":"ribbon-spring-cloud负载均衡与服务调用组件","link":"#ribbon-spring-cloud负载均衡与服务调用组件","children":[{"level":3,"title":"简介","slug":"简介-1","link":"#简介-1","children":[]},{"level":3,"title":"负载均衡","slug":"负载均衡","link":"#负载均衡","children":[]},{"level":3,"title":"Ribbon 实现服务调用","slug":"ribbon-实现服务调用","link":"#ribbon-实现服务调用","children":[]}]},{"level":2,"title":"OpenFeign：Spring Cloud声明式服务调用组件","slug":"openfeign-spring-cloud声明式服务调用组件","link":"#openfeign-spring-cloud声明式服务调用组件","children":[{"level":3,"title":"OpenFeign","slug":"openfeign","link":"#openfeign","children":[]},{"level":3,"title":"Feign VS OpenFeign","slug":"feign-vs-openfeign","link":"#feign-vs-openfeign","children":[]},{"level":3,"title":"openfeign参数传递","slug":"openfeign参数传递","link":"#openfeign参数传递","children":[]},{"level":3,"title":"OpenFeign 日志增强","slug":"openfeign-日志增强","link":"#openfeign-日志增强","children":[]}]},{"level":2,"title":"Hystrix：Spring Cloud服务熔断与降级组件","slug":"hystrix-spring-cloud服务熔断与降级组件","link":"#hystrix-spring-cloud服务熔断与降级组件","children":[{"level":3,"title":"服务雪崩","slug":"服务雪崩","link":"#服务雪崩","children":[]},{"level":3,"title":"熔断器","slug":"熔断器","link":"#熔断器","children":[]},{"level":3,"title":"Spring Cloud Hystrix","slug":"spring-cloud-hystrix","link":"#spring-cloud-hystrix","children":[]},{"level":3,"title":"Hystrix 服务降级","slug":"hystrix-服务降级","link":"#hystrix-服务降级","children":[]}]},{"level":2,"title":"Config 配置中心","slug":"config-配置中心","link":"#config-配置中心","children":[]}],"relativePath":"articles/java/SpringCloud.md"}'),o={name:"articles/java/SpringCloud.md"},s=r(`<h1 id="springcloud笔记" tabindex="-1">SpringCloud笔记 <a class="header-anchor" href="#springcloud笔记" aria-hidden="true">#</a></h1><h2 id="springcloud" tabindex="-1">SpringCloud <a class="header-anchor" href="#springcloud" aria-hidden="true">#</a></h2><h3 id="springcloud-是什么" tabindex="-1">SpringCloud 是什么 <a class="header-anchor" href="#springcloud-是什么" aria-hidden="true">#</a></h3><p>Spring Cloud 是一款基于 Spring Boot 实现的微服务框架。Spring Cloud 源自 Spring 社区，主要由 Pivotal 和 Netflix 两大公司提供技术迭代和维护。</p><p>随着微服务的火爆流行，国内外各大互联网公司都相继分享了他们在微服务架构中，针对不同场景出现的各种问题的解决方案和开源框架。</p><ul><li><strong>服务治理</strong>：阿里巴巴开源的 Dubbo 和当当网在其基础上扩展出来的 DubboX、Netflix 的 Eureka 以及 Apache 的 Consul 等。</li><li><strong>分布式配置管理</strong>：百度的 Disconf、Netflix 的 Archaius、360 的 QConf、携程的 Apollo 以及 Spring Cloud 的 Config 等。</li><li><strong>批量任务</strong>：当当网的 Elastic-Job、LinkedIn 的 Azkaban 以及 Spring Cloud 的 Task 等。</li><li><strong>服务跟踪</strong>：京东的 Hydra、Spring Cloud 的 Sleuth 以及 Twitter 的 Zipkin 等。</li><li><strong>……</strong></li></ul><p>以上这些微服务框架或解决方案都具有以下 2 个特点：</p><ul><li>对于同一个微服务问题，各互联网公司给出的解决方案各不相同。</li><li>一个微服务框架或解决方案都只能解决微服务中的某一个或某几个问题，对于其他问题则无能为力。</li></ul><p>这种情况下，搭建一套微分布式微服务系统，就需要针对这些问题从诸多的解决方案中做出选择，这使得我们不得不将大量的精力花费在前期的调研、分析以及实验上。</p><p>Spring Cloud 被称为构建分布式微服务系统的“全家桶”，它并不是某一门技术，而是一系列微服务解决方案或框架的有序集合。它将市面上成熟的、经过验证的微服务框架整合起来，并通过 Spring Boot 的思想进行再封装，屏蔽调其中复杂的配置和实现原理，最终为开发人员提供了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p>Spring Cloud 中包含了 spring-cloud-config、spring-cloud-bus 等近 20 个子项目，提供了服务治理、服务网关、智能路由、负载均衡、断路器、监控跟踪、分布式消息队列、配置管理等领域的解决方案。</p><p>Spring Cloud 并不是一个拿来即可用的框架，它是一种微服务规范，共有以下 2 代实现：</p><ul><li>第一代实现：Spring Cloud Netflix</li><li>第二代实现：Spring Cloud Alibaba</li></ul><p>这里我们介绍的 Spring Cloud 特指 Spring Cloud 的第一代实现。</p><h3 id="spring-cloud-常用组件" tabindex="-1">Spring Cloud 常用组件 <a class="header-anchor" href="#spring-cloud-常用组件" aria-hidden="true">#</a></h3><p>Spring Cloud 包括 Spring Cloud Gateway、Spring Cloud Config、Spring Cloud Bus 等近 20 个服务组件，这些组件提供了服务治理、服务网关、智能路由、负载均衡、熔断器、监控跟踪、分布式消息队列、配置管理等领域的解决方案。</p><p>Spring Cloud 的常用组件如下表所示。</p><table><thead><tr><th>Spring Cloud 组件</th><th>描述</th></tr></thead><tbody><tr><td>Spring Cloud Netflix Eureka</td><td>Spring Cloud Netflix 中的服务治理组件，包含服务注册中心、服务注册与发现机制的实现。</td></tr><tr><td>Spring Cloud Netflix Ribbon</td><td>Spring Cloud Netflix 中的服务调用和客户端负载均衡组件。</td></tr><tr><td>Spring Cloud Netflix Hystrix</td><td>人称“豪猪哥”，Spring Cloud Netflix 的容错管理组件，为服务中出现的延迟和故障提供强大的容错能力。</td></tr><tr><td>Spring Cloud Netflix Feign</td><td>基于 Ribbon 和 Hystrix 的声明式服务调用组件。</td></tr><tr><td>Spring Cloud Netflix Zuul</td><td>Spring Cloud Netflix 中的网关组件，提供了智能路由、访问过滤等功能。</td></tr><tr><td>Spring Cloud Gateway</td><td>一个基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关框架，它使用 Filter 链的方式提供了网关的基本功能，例如安全、监控/指标和限流等。</td></tr><tr><td>Spring Cloud Config</td><td>Spring Cloud 的配置管理工具，支持使用 Git 存储配置内容，实现应用配置的外部化存储，并支持在客户端对配置进行刷新、加密、解密等操作。</td></tr><tr><td>Spring Cloud Bus</td><td>Spring Cloud 的事件和消息总线，主要用于在集群中传播事件或状态变化，以触发后续的处理，例如动态刷新配置。</td></tr><tr><td>Spring Cloud Stream</td><td>Spring Cloud 的消息中间件组件，它集成了 Apache Kafka 和 RabbitMQ 等消息中间件，并通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件之间的隔离。通过向应用程序暴露统一的 Channel 通道，使得应用程序不需要再考虑各种不同的消息中间件实现，就能轻松地发送和接收消息。</td></tr><tr><td>Spring Cloud Sleuth</td><td>Spring Cloud 分布式链路跟踪组件，能够完美的整合 Twitter 的 Zipkin。</td></tr></tbody></table><blockquote><p>注：Netflix 是美国的一个在线视频网站，它是公认的大规模生产级微服务的杰出实践者，微服务界的翘楚。Netflix 的开源组件已经在其大规模分布式微服务环境中经过了多年的生产实战验证，成熟且可靠。</p></blockquote><h3 id="spring-boot-和-spring-cloud-的区别与联系" tabindex="-1">Spring Boot 和 Spring Cloud 的区别与联系 <a class="header-anchor" href="#spring-boot-和-spring-cloud-的区别与联系" aria-hidden="true">#</a></h3><p>Spring Boot 和 Spring Cloud 都是 Spring 大家族的一员，它们在微服务开发中都扮演着十分重要的角色，两者之间既存在区别也存在联系。</p><ol><li>Spring Boot 和 Spring Cloud 分工不同</li></ol><p>Spring Boot 是一个基于 Spring 的快速开发框架，它能够帮助开发者迅速搭 Web 工程。在微服务开发中，Spring Boot 专注于快速、方便地开发单个微服务。</p><p>Spring Cloud 是微服务架构下的一站式解决方案。Spring Cloud 专注于全局微服务的协调和治理工作。换句话说，Spring Cloud 相当于微服务的大管家，负责将 Spring Boot 开发的一个个微服务管理起来，并为它们提供配置管理、服务发现、断路器、路由、微代理、事件总线、决策竞选以及分布式会话等服务。</p><ol start="2"><li>Spring Cloud 是基于 Spring Boot 实现的</li></ol><p>Spring Cloud 是基于 Spring Boot 实现的。与 Spring Boot 类似，Spring Cloud 也为提供了一系列 Starter，这些 Starter 是 Spring Cloud 使用 Spring Boot 思想对各个微服务框架进行再封装的产物。它们屏蔽了这些微服务框架中复杂的配置和实现原理，使开发人员能够快速、方便地使用 Spring Cloud 搭建一套分布式微服务系统。</p><ol start="3"><li>Spring Boot 和 Spring Cloud 依赖项数量不同</li></ol><p>Spring Boot 属于一种轻量级的框架，构建 Spring Boot 工程所需的依赖较少。</p><p>Spring Cloud 是一系列微服务框架技术的集合体，它的每个组件都需要一个独立的依赖项（Starter POM），因此想要构建一套完整的 Spring Cloud 工程往往需要大量的依赖项。</p><ol start="4"><li>Spring Cloud 不能脱离 Spring Boot 单独运行</li></ol><p>Spring Boot 不需要 Spring Cloud，就能直接创建可独立运行的工程或模块。</p><p>Spring Cloud 是基于 Spring Boot 实现的，它不能独立创建工程或模块，更不能脱离 Spring Boot 独立运行。</p><blockquote><p>注意：虽然 Spring Boot 能够用于开发单个微服务，但它并不具备管理和协调微服务的能力，因此它只能算是一个微服务快速开发框架，而非微服务框架。</p></blockquote><h3 id="spring-cloud-版本" tabindex="-1">Spring Cloud 版本 <a class="header-anchor" href="#spring-cloud-版本" aria-hidden="true">#</a></h3><p>Spring Cloud 包含了许多子项目（组件），这些子项目都是独立进行内容更新和迭代的，各自都维护着自己的发布版本号。</p><p>为了避免 Spring Cloud 的版本号与其子项目的版本号混淆，Spring Cloud 没有采用常见的数字版本号，而是通过以下方式定义版本信息。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">{version.name} .{version.number}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Spring Cloud 版本信息说明如下：</p><ul><li><strong><a href="http://version.name" target="_blank" rel="noreferrer">version.name</a></strong>：版本名，采用英国伦敦地铁站的站名来命名，并按照字母表的顺序（即从 A 到 Z）来对应 Spring Cloud 的版本发布顺序，例如第一个版本为 Angel，第二个版本为 Brixton（英国地名），然后依次是 Camden、Dalston、Edgware、Finchley、Greenwich、Hoxton 等。</li><li><strong>version.number</strong>：版本号，每一个版本的 Spring Cloud 在更新内容积累到一定的量级或有重大 BUG 修复时，就会发布一个“service releases”版本，简称 SRX 版本，其中 X 为一个递增的数字，例如 Hoxton.SR8 就表示 Hoxton 的第 8 个 Release 版本。</li></ul><h3 id="spring-cloud-版本选择" tabindex="-1">Spring Cloud 版本选择 <a class="header-anchor" href="#spring-cloud-版本选择" aria-hidden="true">#</a></h3><p>在使用 Spring Boot + Spring Cloud 进行微服务开发时，我们需要根据项目中 Spring Boot 的版本来决定 Spring Cloud 版本，否则会出现许多意想不到的错误。</p><p>Spring Boot 与 Spring Cloud 的版本对应关系如下表（参考自<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noreferrer"></a><a href="http://spring.io/projects/spring-cloud" target="_blank" rel="noreferrer">Spring Cloud 官网</a>）。</p><table><thead><tr><th>Spring Cloud</th><th>Spring Boot</th></tr></thead><tbody><tr><td>2020.0.x （Ilford）</td><td>2.4.x, 2.5.x （从 Spring Cloud 2020.0.3 开始）</td></tr><tr><td>Hoxton</td><td>2.2.x, 2.3.x （从 Spring Cloud SR5 开始）</td></tr><tr><td>Greenwich</td><td>2.1.x</td></tr><tr><td>Finchley</td><td>2.0.x</td></tr><tr><td>Edgware</td><td>1.5.x</td></tr><tr><td>Dalston</td><td>1.5.x</td></tr></tbody></table><blockquote><p>注意：Spring Cloud 官方已经停止对 Dalston、Edgware、Finchley 和 Greenwich 的版本更新。</p></blockquote><p>除了上表中展示的版本对应关系之外，我们还可以使用浏览器访问 <a href="https://start.spring.io/actuator/info%EF%BC%8C%E8%8E%B7%E5%8F%96" target="_blank" rel="noreferrer">https://start.spring.io/actuator/info，获取</a> Spring Cloud 与 Spring Boot 的版本对应关系（JSON 版）。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">spring-cloud</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">: </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">Hoxton.SR12</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Spring Boot &gt;=2.2.0.RELEASE and &lt;2.4.0.M1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">2020.0.6</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Spring Boot &gt;=2.4.0.M1 and &lt;2.6.0-M1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">2021.0.0-M1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Spring Boot &gt;=2.6.0-M1 and &lt;2.6.0-M3</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">2021.0.0-M3</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Spring Boot &gt;=2.6.0-M3 and &lt;2.6.0-RC1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">2021.0.0-RC1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Spring Boot &gt;=2.6.0-RC1 and &lt;2.6.1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">2021.0.4</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Spring Boot &gt;=2.6.1 and &lt;3.0.0-M1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">2022.0.0-M1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Spring Boot &gt;=3.0.0-M1 and &lt;3.0.0-M2</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">2022.0.0-M2</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Spring Boot &gt;=3.0.0-M2 and &lt;3.0.0-M3</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">2022.0.0-M3</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Spring Boot &gt;=3.0.0-M3 and &lt;3.0.0-M4</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">2022.0.0-M4</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Spring Boot &gt;=3.0.0-M4 and &lt;3.0.0-M5</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">2022.0.0-M5</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Spring Boot &gt;=3.0.0-M5 and &lt;3.1.0-M1</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">,</span></span>
<span class="line"></span></code></pre></div><h2 id="eureka-spring-cloud服务注册与发现组件" tabindex="-1">Eureka：Spring Cloud服务注册与发现组件 <a class="header-anchor" href="#eureka-spring-cloud服务注册与发现组件" aria-hidden="true">#</a></h2><h3 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-hidden="true">#</a></h3><p>Eureka 一词来源于古希腊词汇，是“发现了”的意思。在软件领域，Eureka 是 Netflix 公司开发的一款开源的服务注册与发现组件。</p><p>Spring Cloud 将 Eureka 与 Netflix 中的其他开源服务组件（例如 Ribbon、Feign 以及 Hystrix 等）一起整合进 Spring Cloud Netflix 模块中，整合后的组件全称为 Spring Cloud Netflix Eureka。</p><p>Eureka 是 Spring Cloud Netflix 模块的子模块，它是 Spring Cloud 对 Netflix Eureka 的二次封装，主要负责 Spring Cloud 的服务注册与发现功能。</p><p>Spring Cloud 使用 Spring Boot 思想为 Eureka 增加了自动化配置，开发人员只需要引入相关依赖和注解，就能将 Spring Boot 构建的微服务轻松地与 Eureka 进行整合。</p><h3 id="eureka两大组件" tabindex="-1">Eureka两大组件 <a class="header-anchor" href="#eureka两大组件" aria-hidden="true">#</a></h3><p>Eureka 采用 CS（Client/Server，客户端/服务器） 架构，它包括以下两大组件：</p><ul><li><strong>Eureka Server</strong>：Eureka 服务注册中心，主要用于提供服务注册功能。当微服务启动时，会将自己的服务注册到 Eureka Server。Eureka Server 维护了一个可用服务列表，存储了所有注册到 Eureka Server 的可用服务的信息，这些可用服务可以在 Eureka Server 的管理界面中直观看到。</li><li><strong>Eureka Client</strong>：Eureka 客户端，通常指的是微服务系统中各个微服务，主要用于和 Eureka Server 进行交互。在微服务应用启动后，Eureka Client 会向 Eureka Server 发送心跳（默认周期为 30 秒）。若 Eureka Server 在多个心跳周期内没有接收到某个 Eureka Client 的心跳，Eureka Server 将它从可用服务列表中移除（默认 90 秒）。</li></ul><p><code>注：“心跳”指的是一段定时发送的自定义信息，让对方知道自己“存活”，以确保连接的有效性。大部分 CS 架构的应用程序都采用了心跳机制，服务端和客户端都可以发心跳。通常情况下是客户端向服务器端发送心跳包，服务端用于判断客户端是否在线。</code></p><h3 id="eureka-服务注册与发现" tabindex="-1">Eureka 服务注册与发现 <a class="header-anchor" href="#eureka-服务注册与发现" aria-hidden="true">#</a></h3><p>Eureka 实现服务注册与发现的原理，如下图所示。</p><p><img src="`+a+'" alt="Eureka原理图"></p><p>上图中共涉及到以下 3 个角色：</p><ul><li><strong>服务注册中心（Register Service）</strong>：它是一个 Eureka Server，用于提供服务注册和发现功能。</li><li><strong>服务提供者（Provider Service）</strong>：它是一个 Eureka Client，用于提供服务。它将自己提供的服务注册到服务注册中心，以供服务消费者发现。</li><li><strong>服务消费者（Consumer Service）</strong>：它是一个 Eureka Client，用于消费服务。它可以从服务注册中心获取服务列表，调用所需的服务。</li></ul><p>Eureka 实现服务注册与发现的流程如下：</p><ol><li>搭建一个 Eureka Server 作为服务注册中心；</li><li>服务提供者 Eureka Client 启动时，会把当前服务器的信息以服务名（<a href="http://spring.application.name" target="_blank" rel="noreferrer">spring.application.name</a>）的方式注册到服务注册中心；</li><li>服务消费者 Eureka Client 启动时，也会向服务注册中心注册；</li><li>服务消费者还会获取一份可用服务列表，该列表中包含了所有注册到服务注册中心的服务信息（包括服务提供者和自身的信息）；</li><li>在获得了可用服务列表后，服务消费者通过 HTTP 或消息中间件远程调用服务提供者提供的服务。</li></ol><p>服务注册中心（Eureka Server）所扮演的角色十分重要，它是服务提供者和服务消费者之间的桥梁。服务提供者只有将自己的服务注册到服务注册中心才可能被服务消费者调用，而服务消费者也只有通过服务注册中心获取可用服务列表后，才能调用所需的服务。</p><h3 id="eureka-springcloud-官方地址" tabindex="-1">Eureka SpringCloud 官方地址 <a class="header-anchor" href="#eureka-springcloud-官方地址" aria-hidden="true">#</a></h3><p><a href="https://docs.spring.io/spring-cloud-netflix/docs/3.1.4/reference/html/#refreshing-eureka-clients" target="_blank" rel="noreferrer">Spring Cloud Netflix</a></p><h2 id="ribbon-spring-cloud负载均衡与服务调用组件" tabindex="-1">Ribbon：Spring Cloud负载均衡与服务调用组件 <a class="header-anchor" href="#ribbon-spring-cloud负载均衡与服务调用组件" aria-hidden="true">#</a></h2><h3 id="简介-1" tabindex="-1">简介 <a class="header-anchor" href="#简介-1" aria-hidden="true">#</a></h3><p>Spring Cloud Ribbon 是一套基于 Netflix Ribbon 实现的客户端负载均衡和服务调用工具。</p><p>Netflix Ribbon 是 Netflix 公司发布的开源组件，其主要功能是提供客户端的负载均衡算法和服务调用。Spring Cloud 将其与 Netflix 中的其他开源服务组件（例如 Eureka、Feign 以及 Hystrix 等）一起整合进 Spring Cloud Netflix 模块中，整合后全称为 Spring Cloud Netflix Ribbon。</p><p>Ribbon 是 Spring Cloud Netflix 模块的子模块，它是 Spring Cloud 对 Netflix Ribbon 的二次封装。通过它，我们可以将面向服务的 REST 模板（RestTemplate）请求转换为客户端负载均衡的服务调用。</p><p>Ribbon 是 Spring Cloud 体系中最核心、最重要的组件之一。它虽然只是一个工具类型的框架，并不像 Eureka Server（服务注册中心）那样需要独立部署，但它几乎存在于每一个使用 Spring Cloud 构建的微服务中。</p><p>Spring Cloud 微服务之间的调用，API 网关的请求转发等内容，实际上都是通过 Spring Cloud Ribbon 来实现的，包括后续我们要介绍的 <a href="http://c.biancheng.net/springcloud/open-feign.html" target="_blank" rel="noreferrer">OpenFeign</a> 也是基于它实现的。</p><h3 id="负载均衡" tabindex="-1">负载均衡 <a class="header-anchor" href="#负载均衡" aria-hidden="true">#</a></h3><p>在任何一个系统中，负载均衡都是一个十分重要且不得不去实施的内容，它是系统处理高并发、缓解网络压力和服务端扩容的重要手段之一。</p><p>负载均衡（Load Balance） ，简单点说就是将用户的请求平摊分配到多个服务器上运行，以达到扩展服务器带宽、增强数据处理能力、增加吞吐量、提高网络的可用性和灵活性的目的。</p><p>常见的负载均衡方式有两种：</p><ul><li>服务端负载均衡</li><li>客户端负载均衡</li></ul><h4 id="服务端负载均衡" tabindex="-1">服务端负载均衡 <a class="header-anchor" href="#服务端负载均衡" aria-hidden="true">#</a></h4><p>服务端负载均衡是最常见的负载均衡方式，其工作原理如下图。</p><p><img src="'+t+'" alt="服务端负载均衡工作原理"></p><p>服务端负载均衡是在客户端和服务端之间建立一个独立的负载均衡服务器，该服务器既可以是硬件设备（例如 F5），也可以是软件（例如 Nginx）。这个负载均衡服务器维护了一份可用服务端清单，然后通过心跳机制来删除故障的服务端节点，以保证清单中的所有服务节点都是可以正常访问的。</p><p>当客户端发送请求时，该请求不会直接发送到服务端进行处理，而是全部交给负载均衡服务器，由负载均衡服务器按照某种算法（例如轮询、随机等），从其维护的可用服务清单中选择一个服务端，然后进行转发。</p><p>服务端负载均衡具有以下特点：</p><ul><li>需要建立一个独立的负载均衡服务器。</li><li>负载均衡是在客户端发送请求后进行的，因此客户端并不知道到底是哪个服务端提供的服务。</li><li>可用服务端清单存储在负载均衡服务器上。</li></ul><h4 id="客户端负载均衡" tabindex="-1">客户端负载均衡 <a class="header-anchor" href="#客户端负载均衡" aria-hidden="true">#</a></h4><p>相较于服务端负载均衡，客户端服务在均衡则是一个比较小众的概念。</p><p>客户端负载均衡的工作原理如下图。</p><p><img src="'+i+`" alt="客户端负载均衡原理"></p><p>客户端负载均衡是将负载均衡逻辑以代码的形式封装到客户端上，即负载均衡器位于客户端。客户端通过服务注册中心（例如 Eureka Server）获取到一份服务端提供的可用服务清单。有了服务清单后，负载均衡器会在客户端发送请求前通过负载均衡算法选择一个服务端实例再进行访问，以达到负载均衡的目的；</p><p>客户端负载均衡也需要心跳机制去维护服务端清单的有效性，这个过程需要配合服务注册中心一起完成。</p><p>客户端负载均衡具有以下特点：</p><ul><li>负载均衡器位于客户端，不需要单独搭建一个负载均衡服务器。</li><li>负载均衡是在客户端发送请求前进行的，因此客户端清楚地知道是哪个服务端提供的服务。</li><li>客户端都维护了一份可用服务清单，而这份清单都是从服务注册中心获取的。</li></ul><p>Ribbon 就是一个基于 HTTP 和 TCP 的客户端负载均衡器，当我们将 Ribbon 和 Eureka 一起使用时，Ribbon 会从 Eureka Server（服务注册中心）中获取服务端列表，然后通过负载均衡策略将请求分摊给多个服务提供者，从而达到负载均衡的目的。</p><h4 id="服务端负载均衡-vs-客户端负载均衡" tabindex="-1">服务端负载均衡 VS 客户端负载均衡 <a class="header-anchor" href="#服务端负载均衡-vs-客户端负载均衡" aria-hidden="true">#</a></h4><p>下面我们就来对比下，服务端负载均衡和客户端负载均衡到底有什么区别，如下表。</p><table><thead><tr><th>不同点</th><th>服务端负载均衡</th><th>客户端负载均衡</th></tr></thead><tbody><tr><td>是否需要建立负载均衡服务器</td><td>需要在客户端和服务端之间建立一个独立的负载均衡服务器。</td><td>将负载均衡的逻辑以代码的形式封装到客户端上，因此不需要单独建立负载均衡服务器。</td></tr><tr><td>是否需要服务注册中心</td><td>不需要服务注册中心。</td><td>需要服务注册中心。 在客户端负载均衡中，所有的客户端和服务端都需要将其提供的服务注册到服务注册中心上。</td></tr><tr><td>可用服务清单存储的位置</td><td>可用服务清单存储在位于客户端与服务器之间的负载均衡服务器上。</td><td>所有的客户端都维护了一份可用服务清单，这些清单都是从服务注册中心获取的。</td></tr><tr><td>负载均衡的时机</td><td>先将请求发送到负载均衡服务器，然后由负载均衡服务器通过负载均衡算法，在多个服务端之间选择一个进行访问；即在服务器端再进行负载均衡算法分配。 简单点说就是，先发送请求，再进行负载均衡。</td><td>在发送请求前，由位于客户端的服务负载均衡器（例如 Ribbon）通过负载均衡算法选择一个服务器，然后进行访问。 简单点说就是，先进行负载均衡，再发送请求。</td></tr><tr><td>客户端是否了解服务提供方信息</td><td>由于负载均衡是在客户端发送请求后进行的，因此客户端并不知道到底是哪个服务端提供的服务。</td><td>负载均衡是在客户端发送请求前进行的，因此客户端清楚的知道是哪个服务端提供的服务。</td></tr></tbody></table><h3 id="ribbon-实现服务调用" tabindex="-1">Ribbon 实现服务调用 <a class="header-anchor" href="#ribbon-实现服务调用" aria-hidden="true">#</a></h3><p>Ribbon 可以与 RestTemplate（Rest 模板）配合使用，以实现微服务之间的调用。</p><p>RestTemplate 是 Spring 家族中的一个用于消费第三方 REST 服务的请求框架。RestTemplate 实现了对 HTTP 请求的封装，提供了一套模板化的服务调用方法。通过它，Spring 应用可以很方便地对各种类型的 HTTP 请求进行访问。</p><p>RestTemplate 针对各种类型的 HTTP 请求都提供了相应的方法进行处理，例如 HEAD、GET、POST、PUT、DELETE 等类型的 HTTP 请求，分别对应 RestTemplate 中的 headForHeaders()、getForObject()、postForObject()、put() 以及 delete() 方法。</p><h2 id="openfeign-spring-cloud声明式服务调用组件" tabindex="-1">OpenFeign：Spring Cloud声明式服务调用组件 <a class="header-anchor" href="#openfeign-spring-cloud声明式服务调用组件" aria-hidden="true">#</a></h2><p>Netflix Feign 是 Netflix 公司发布的一种实现负载均衡和服务调用的开源组件。Spring Cloud 将其与 Netflix 中的其他开源服务组件（例如 Eureka、Ribbon 以及 Hystrix 等）一起整合进 Spring Cloud Netflix 模块中，整合后全称为 Spring Cloud Netflix Feign。</p><p>Feign 对 <a href="http://c.biancheng.net/springcloud/ribbon.html" target="_blank" rel="noreferrer">Ribbon</a> 进行了集成，利用 Ribbon 维护了一份可用服务清单，并通过 Ribbon 实现了客户端的负载均衡。</p><p>Feign 是一种声明式服务调用组件，它在 RestTemplate 的基础上做了进一步的封装。通过 Feign，我们只需要声明一个接口并通过注解进行简单的配置（类似于 Dao 接口上面的 Mapper 注解一样）即可实现对 HTTP 接口的绑定。</p><p>通过 Feign，我们可以像调用本地方法一样来调用远程服务，而完全感觉不到这是在进行远程调用。</p><p>Feign 支持多种注解，例如 Feign 自带的注解以及 JAX-RS 注解等，但遗憾的是 Feign 本身并不支持 Spring MVC 注解，这无疑会给广大 Spring 用户带来不便。</p><p>2019 年 Netflix 公司宣布 Feign 组件正式进入停更维护状态，于是 Spring 官方便推出了一个名为 OpenFeign 的组件作为 Feign 的替代方案。</p><h3 id="openfeign" tabindex="-1">OpenFeign <a class="header-anchor" href="#openfeign" aria-hidden="true">#</a></h3><p>OpenFeign 全称 Spring Cloud OpenFeign，它是 Spring 官方推出的一种声明式服务调用与负载均衡组件，它的出现就是为了替代进入停更维护状态的 Feign。</p><p>OpenFeign 是 Spring Cloud 对 Feign 的二次封装，它具有 Feign 的所有功能，并在 Feign 的基础上增加了对 Spring MVC 注解的支持，例如 @RequestMapping、@GetMapping 和 @PostMapping 等。</p><h4 id="openfeign-常用注解" tabindex="-1">OpenFeign 常用注解 <a class="header-anchor" href="#openfeign-常用注解" aria-hidden="true">#</a></h4><p>使用 OpenFegin 进行远程服务调用时，常用注解如下表。</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@FeignClient</td><td>该注解用于通知 OpenFeign 组件对 @RequestMapping 注解下的接口进行解析，并通过动态代理的方式产生实现类，实现负载均衡和服务调用。</td></tr><tr><td>@EnableFeignClients</td><td>该注解用于开启 OpenFeign 功能，当 Spring Cloud 应用启动时，OpenFeign 会扫描标有 @FeignClient 注解的接口，生成代理并注册到 Spring 容器中。</td></tr><tr><td>@RequestMapping</td><td>Spring MVC 注解，在 Spring MVC 中使用该注解映射请求，通过它来指定控制器（Controller）可以处理哪些 URL 请求，相当于 Servlet 中 web.xml 的配置。</td></tr><tr><td>@GetMapping</td><td>Spring MVC 注解，用来映射 GET 请求，它是一个组合注解，相当于 @RequestMapping(method = RequestMethod.GET) 。</td></tr><tr><td>@PostMapping</td><td>Spring MVC 注解，用来映射 POST 请求，它是一个组合注解，相当于 @RequestMapping(method = RequestMethod.POST) 。</td></tr></tbody></table><blockquote><p>Spring Cloud Finchley 及以上版本一般使用 OpenFeign 作为其服务调用组件。由于 OpenFeign 是在 2019 年 Feign 停更进入维护后推出的，因此大多数 2019 年及以后的新项目使用的都是 OpenFeign，而 2018 年以前的项目一般使用 Feign。</p></blockquote><h3 id="feign-vs-openfeign" tabindex="-1">Feign VS OpenFeign <a class="header-anchor" href="#feign-vs-openfeign" aria-hidden="true">#</a></h3><p>下面我们就来对比下 Feign 和 OpenFeign 的异同。</p><h4 id="相同点" tabindex="-1">相同点 <a class="header-anchor" href="#相同点" aria-hidden="true">#</a></h4><p>Feign 和 OpenFegin 具有以下相同点：</p><ul><li>Feign 和 OpenFeign 都是 Spring Cloud 下的远程调用和负载均衡组件。</li><li>Feign 和 OpenFeign 作用一样，都可以实现服务的远程调用和负载均衡。</li><li>Feign 和 OpenFeign 都对 Ribbon 进行了集成，都利用 Ribbon 维护了可用服务清单，并通过 Ribbon 实现了客户端的负载均衡。</li><li>Feign 和 OpenFeign 都是在服务消费者（客户端）定义服务绑定接口并通过注解的方式进行配置，以实现远程服务的调用。</li></ul><h4 id="不同点" tabindex="-1">不同点 <a class="header-anchor" href="#不同点" aria-hidden="true">#</a></h4><p>Feign 和 OpenFeign 具有以下不同：</p><ul><li>Feign 和 OpenFeign 的依赖项不同，Feign 的依赖为 spring-cloud-starter-feign，而 OpenFeign 的依赖为 spring-cloud-starter-openfeign。</li><li>Feign 和 OpenFeign 支持的注解不同，Feign 支持 Feign 注解和 JAX-RS 注解，但不支持 Spring MVC 注解；OpenFeign 除了支持 Feign 注解和 JAX-RS 注解外，还支持 Spring MVC 注解。</li></ul><h3 id="openfeign参数传递" tabindex="-1">openfeign参数传递 <a class="header-anchor" href="#openfeign参数传递" aria-hidden="true">#</a></h3><p>需要添加注解</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">RequestBody</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">RequestParam</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">date</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">PathVariable</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">username</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"></span></code></pre></div><blockquote><p>注意，在Feign中要在后面指定value值</p><p>传递时间类型会 +- 14个小时，不建议单独传递时间，建议转成字符串或包到对象中，或者使用jdk</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">LocalDate</span><span style="color:#A6ACCD;"> localDate </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> LocalDate</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">now</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 年月日</span></span>
<span class="line"><span style="color:#C792EA;">LocalDateTime</span><span style="color:#A6ACCD;"> localDateTime </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> LocalDateTime</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">now</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 时间，会丢失秒</span></span>
<span class="line"></span></code></pre></div></blockquote><h3 id="openfeign-日志增强" tabindex="-1">OpenFeign 日志增强 <a class="header-anchor" href="#openfeign-日志增强" aria-hidden="true">#</a></h3><p>OpenFeign 提供了日志打印功能，我们可以通过配置调整日志级别，来了解请求的细节。</p><p>Feign 为每一个 FeignClient 都提供了一个 feign.Logger 实例，通过它可以对 OpenFeign 服务绑定接口的调用情况进行监控。</p><p>Logger.Level 的具体级别如下：</p><ul><li>NONE：不记录任何信息。</li><li>BASIC：仅记录请求方法、URL 以及响应状态码和执行时间。</li><li>HEADERS：除了记录 BASIC 级别的信息外，还会记录请求和响应的头信息。</li><li>FULL：记录所有请求与响应的明细，包括头信息、请求体、元数据等等。</li></ul><h2 id="hystrix-spring-cloud服务熔断与降级组件" tabindex="-1">Hystrix：Spring Cloud服务熔断与降级组件 <a class="header-anchor" href="#hystrix-spring-cloud服务熔断与降级组件" aria-hidden="true">#</a></h2><h3 id="服务雪崩" tabindex="-1">服务雪崩 <a class="header-anchor" href="#服务雪崩" aria-hidden="true">#</a></h3><p>在分布式的链路中，只要有一个服务宕机，就可能导致一整个业务链都瘫痪</p><p>服务雪崩的核心本质是什么？</p><p>线程没有及时回收</p><p>熔断</p><p>直接return，业务是不能完成的，但是可以缓解服务器压力</p><ol><li>调整等待时间，这样可以缓解压力，很有局限性，不灵活，有的服务可能需要很多的时间去执行</li><li>在上游服务知道下一个服务的状，如果是ok的，就正常访问，如果宕机了，那么就return，这样就可以缓解服务雪崩</li></ol><p>我们可以容忍服务挂掉，我们需要做对应的调整，我们可以设置一个备选方案（备胎）</p><p>在微服务架构中，一个应用往往由多个服务组成，这些服务之间相互依赖，依赖关系错综复杂。</p><p>例如一个微服务系统中存在 A、B、C、D、E、F 等多个服务，它们的依赖关系如下图。</p><p><img src="`+p+'" alt="img"></p><p>通常情况下，一个用户请求往往需要多个服务配合才能完成。如图 1 所示，在所有服务都处于可用状态时，请求 1 需要调用 A、D、E、F 四个服务才能完成，请求 2 需要调用 B、E、D 三个服务才能完成，请求 3 需要调用服务 C、F、E、D 四个服务才能完成。</p><p>当服务 E 发生故障或网络延迟时，会出现以下情况：</p><ol><li>即使其他所有服务都可用，由于服务 E 的不可用，那么用户请求 1、2、3 都会处于阻塞状态，等待服务 E 的响应。在高并发的场景下，会导致整个服务器的线程资源在短时间内迅速消耗殆尽。</li><li>所有依赖于服务 E 的其他服务，例如服务 B、D 以及 F 也都会处于线程阻塞状态，等待服务 E 的响应，导致这些服务的不可用。</li><li>所有依赖服务B、D 和 F 的服务，例如服务 A 和服务 C 也会处于线程阻塞状态，以等待服务 D 和服务 F 的响应，导致服务 A 和服务 C 也不可用。</li></ol><p>从以上过程可以看出，当微服务系统的一个服务出现故障时，故障会沿着服务的调用链路在系统中疯狂蔓延，最终导致整个微服务系统的瘫痪，这就是“雪崩效应”。为了防止此类事件的发生，微服务架构引入了“熔断器”的一系列服务容错和保护机制。</p><h3 id="熔断器" tabindex="-1">熔断器 <a class="header-anchor" href="#熔断器" aria-hidden="true">#</a></h3><p>熔断器（Circuit Breaker）一词来源物理学中的电路知识，它的作用是当线路出现故障时，迅速切断电源以保护电路的安全。</p><p>在微服务领域，熔断器最早是由 Martin Fowler 在他发表的 《<a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="noreferrer">Circuit Breake</a>r》一文中提出。与物理学中的熔断器作用相似，微服务架构中的熔断器能够在某个服务发生故障后，向服务调用方返回一个符合预期的、可处理的降级响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常。这样就保证了服务调用方的线程不会被长时间、不必要地占用，避免故障在微服务系统中的蔓延，防止系统雪崩效应的发生。</p><h3 id="spring-cloud-hystrix" tabindex="-1">Spring Cloud Hystrix <a class="header-anchor" href="#spring-cloud-hystrix" aria-hidden="true">#</a></h3><p>Spring Cloud Hystrix 是一款优秀的服务容错与保护组件，也是 Spring Cloud 中最重要的组件之一。</p><p>Spring Cloud Hystrix 是基于 Netflix 公司的开源组件 Hystrix 实现的，它提供了熔断器功能，能够有效地阻止分布式微服务系统中出现联动故障，以提高微服务系统的弹性。Spring Cloud Hystrix 具有服务降级、服务熔断、线程隔离、请求缓存、请求合并以及实时故障监控等强大功能。</p><blockquote><p>Hystrix [hɪst&#39;rɪks]，中文含义是豪猪，豪猪的背上长满了棘刺，使它拥有了强大的自我保护能力。而 Spring Cloud Hystrix 作为一个服务容错与保护组件，也可以让服务拥有自我保护的能力，因此也有人将其戏称为“豪猪哥”。</p></blockquote><p>在微服务系统中，Hystrix 能够帮助我们实现以下目标：</p><ul><li><strong>保护线程资源</strong>：防止单个服务的故障耗尽系统中的所有线程资源。</li><li><strong>快速失败机制</strong>：当某个服务发生了故障，不让服务调用方一直等待，而是直接返回请求失败。</li><li><strong>提供降级（FallBack）方案</strong>：在请求失败后，提供一个设计好的降级方案，通常是一个兜底方法，当请求失败后即调用该方法。</li><li><strong>防止故障扩散</strong>：使用熔断机制，防止故障扩散到其他服务。</li><li><strong>监控功能</strong>：提供熔断器故障监控组件 Hystrix Dashboard，随时监控熔断器的状态。</li></ul><h3 id="hystrix-服务降级" tabindex="-1">Hystrix 服务降级 <a class="header-anchor" href="#hystrix-服务降级" aria-hidden="true">#</a></h3><p>Hystrix 提供了服务降级功能，能够保证当前服务不受其他服务故障的影响，提高服务的健壮性。</p><p>服务降级的使用场景有以下 2 种：</p><ul><li>在服务器压力剧增时，根据实际业务情况及流量，对一些不重要、不紧急的服务进行有策略地不处理或简单处理，从而释放服务器资源以保证核心服务正常运作。</li><li>当某些服务不可用时，为了避免长时间等待造成服务卡顿或雪崩效应，而主动执行备用的降级逻辑立刻返回一个友好的提示，以保障主体业务不受影响。</li></ul><p>我们可以通过重写 HystrixCommand 的 getFallBack() 方法或 HystrixObservableCommand 的 resumeWithFallback() 方法，使服务支持服务降级。</p><p>Hystrix 服务降级 FallBack 既可以放在服务端进行，也可以放在客户端进行。</p><p>Hystrix 会在以下场景下进行服务降级处理：</p><ul><li>程序运行异常</li><li>服务超时</li><li>熔断器处于打开状态</li><li>线程池资源耗尽</li></ul><h2 id="config-配置中心" tabindex="-1">Config 配置中心 <a class="header-anchor" href="#config-配置中心" aria-hidden="true">#</a></h2>',166),d=[s];function g(c,u,h,C,F,D){return e(),l("div",null,d)}const b=n(o,[["render",g]]);export{y as __pageData,b as default};
